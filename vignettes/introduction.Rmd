---
title: "Introduction to vectorialcalculus"
author: "Julio Lizarazo Osorio & Julian Mauricio Fajardo"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to vectorialcalculus}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment  = "#>",
  fig.width = 6, fig.height = 4, dpi = 120,
  eval = FALSE   # set to TRUE when your exported functions are stable
)
```


## Overview

`vectorialcalculus` provides teaching-oriented tools for **2D/3D vector calculus**:
- **Parametric curves**: Frenet frame, curvature, torsion, arc-length.
- **Scalar fields**: gradient, directional derivatives, level sets / isosurfaces.
- **Vector fields**: divergence, curl, flux and circulation.
- **Integrals**: line and surface integrals, numerical quadrature helpers.
- **Visualization**: 2D/3D plots (optionally with `plotly`).

This vignette gives a quick tour using a few representative functions.

## Installation

```{r}
# install.packages("devtools")
devtools::install_github("yourusername/vectorialcalculus")
library(vectorialcalculus)
```

## 1. Line integral in 2D

We compute \eqn{\int_C \mathbf{F}\cdot d\mathbf{r}} along the unit circle.

```{r}
# Vector field F(x,y) = (x, y)
F <- function(x) c(x[1], x[2])

# Parametric curve r(t) = (cos t, sin t), t in [0, 2π]
r <- function(t) c(cos(t), sin(t))

# Numeric line integral (choose "simpson" or "adaptive")
# val <- line_integral_vector2d(F = F, r = r, a = 0, b = 2*pi, method = "simpson", n_simpson = 2000)
# val
```

Optionally, color the curve by the integrand \eqn{\mathbf{F}(r(t))\cdot r'(t)}:

```{r}
# out <- line_integral_vector2d(F, r, a = 0, b = 2*pi, method = "simpson",
#                               plot = TRUE, n_plot = 600)
# out$value
# out$fig
```

## 2. Cylindrical solid and volume

Build the solid
\[
\{(x,y,z): \theta\in[\theta_{\min},\theta_{\max}],\ r\in[R_1(\theta),R_2(\theta)],\ z\in[Z_1(r,\theta),Z_2(r,\theta)]\}
\]
and approximate its volume:
\[
\int_{\theta_{\min}}^{\theta_{\max}}\!\!\int_{R_1(\theta)}^{R_2(\theta)}\!\!
\int_{Z_1(r,\theta)}^{Z_2(r,\theta)} r\,dz\,dr\,d\theta.
\]

```{r}
R1 <- function(theta) 0
R2 <- function(theta) 1 + 0.2*cos(theta)
Z1 <- function(r, theta) 0
Z2 <- function(r, theta) 1 + 0.5*r

# out <- solid_cylindrical3d(
#   R1, R2, Z1, Z2,
#   th_min = 0, th_max = pi/2,
#   plot = TRUE, mode = "both",
#   colorscale = c("white", "#2a9d8f"),
#   opacity = 0.35, show_surface_grid = TRUE,
#   compute_volume = TRUE, vol_method = "adaptive"
# )
# out$volume
# out$fig
```

## 3. Gradient, divergence, and curl (sketch)

Given a scalar field \eqn{f:\mathbb{R}^3\to\mathbb{R}} and a vector field \eqn{\mathbf{F}:\mathbb{R}^3\to\mathbb{R}^3}:

```{r}
# Scalar field
f <- function(x) x[1]^2 + x[2]^2 + x[3]

# Gradient at a point (example: via finite differences inside the package)
# grad <- gradient(f, vars = c("x","y","z"))(c(1,2,3))
# grad

# Vector field
F3 <- function(x) c(-x[2], x[1], 0)

# Divergence and curl at a point
# divF <- divergence(F3)(c(1,2,3))
# curlF <- curl(F3)(c(1,2,3))
# divF; curlF
```

If available, you can visualize vector fields on a grid:

```{r}
# plot_vector_field3d(F3, xlim = c(-2,2), ylim = c(-2,2), zlim = c(0,0), n = 12)
```

## 4. Good practices for numerical stability

- Prefer **adaptive** quadrature for integrals with sharp variations; use **Simpson** on smooth data.
- Increase sampling (`n_plot`, grid sizes) for visualization only—**don’t** confuse plotting resolution with integration accuracy.
- When differentiating numerically, choose a step `h` balancing truncation and rounding errors; expose it as a parameter.

## Reproducibility

```{r}
sessionInfo()
```
