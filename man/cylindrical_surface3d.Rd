% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cylindrical_surface3d.R
\name{cylindrical_surface3d}
\alias{cylindrical_surface3d}
\title{Ruled surface along a 3D curve}
\usage{
cylindrical_surface3d(
  X,
  Y,
  Z,
  a,
  b,
  s_range,
  dir,
  n_t = 200,
  n_s = 60,
  plot = FALSE,
  surface_colorscale = "Blues",
  surface_opacity = 0.35,
  show_surface_grid = TRUE,
  surface_grid_color = "rgba(60,80,200,0.25)",
  surface_grid_width = 1,
  show_curve = TRUE,
  curve_line = list(color = "red", width = 2, dash = "solid"),
  show_edge_a = TRUE,
  show_edge_b = FALSE,
  edge_line = list(color = "blue", width = 2, dash = "solid"),
  show_rulings = TRUE,
  rulings_count = 12,
  rulings_at = NULL,
  rulings_line = list(color = "black", width = 1, dash = "solid"),
  show_axis_grid = FALSE,
  scene = list(aspectmode = "data", xaxis = list(title = "x"), yaxis = list(title = "y"),
    zaxis = list(title = "z")),
  bg = list(paper = "white", plot = "white"),
  lighting = list(ambient = 1, diffuse = 0.15, specular = 0, roughness = 1, fresnel = 0)
)
}
\arguments{
\item{X, Y, Z}{Functions of one variable \code{t} defining the base curve.}

\item{a, b}{Numeric parameter bounds for \code{t}.}

\item{s_range}{Numeric length-2 vector \code{c(s_min, s_max)} for the ruling parameter.}

\item{dir}{Either a character flag (e.g. \code{"tangent"}, \code{"normal"}, \code{"binormal"})
if supported by your implementation, or a function \code{dir(t)} that returns a unit 3D
direction at \code{t}.}

\item{n_t, n_s}{Integers (>= 2): sampling resolution in \code{t} and \code{s}.}

\item{plot}{Logical; if \code{TRUE}, draw the surface with \pkg{plotly}.}

\item{surface_colorscale}{Plotly colorscale name or vector for the surface.}

\item{surface_opacity}{Numeric in \eqn{[0,1]} for surface opacity.}

\item{show_surface_grid}{Logical; draw grid on the surface.}

\item{surface_grid_color}{Color for surface grid lines.}

\item{surface_grid_width}{Numeric width for surface grid lines.}

\item{show_curve}{Logical; overlay the generating curve.}

\item{curve_line}{List of Plotly line aesthetics for the curve
(e.g. \code{list(color = "red", width = 2, dash = "solid")}).}

\item{show_edge_a, show_edge_b}{Logical; show the boundary edges at \code{s = s_min} and \code{s = s_max}.}

\item{edge_line}{List of Plotly line aesthetics for boundary edges.}

\item{show_rulings}{Logical; draw a subset of rulings.}

\item{rulings_count}{Integer; number of rulings to draw if \code{rulings_at} is \code{NULL}.}

\item{rulings_at}{Optional numeric vector of \code{t}-values where rulings are drawn.}

\item{rulings_line}{List of Plotly line aesthetics for rulings.}

\item{show_axis_grid}{Logical; toggle axis grids in the scene.}

\item{scene, bg}{Optional Plotly scene/background lists.}

\item{lighting}{Plotly lighting parameters (list) for surface shading.}
}
\value{
A list with:
\itemize{
\item \code{mesh}: data for the ruled surface (e.g., matrices/df of x,y,z).
\item \code{fig}: Plotly object if \code{plot = TRUE}, else \code{NULL}.
}
}
\description{
Builds (and optionally plots) a ruled surface generated by a space curve
\eqn{C(t) = (X(t), Y(t), Z(t))}, sweeping straight lines (rulings) in a
direction \eqn{d(t)} over a secondary parameter \eqn{s \in [s_{\min}, s_{\max}]}.
}
\examples{
# Helix-based ruled surface with constant direction (simple demo)
X <- function(t) cos(t); Y <- function(t) sin(t); Z <- function(t) 0.3*t
dir_vec <- c(0, 0, 1)  # dirección constante válida
rs <- cylindrical_surface3d(
  X, Y, Z,
  a = 0, b = 2*pi,
  s_range = c(-0.2, 0.2),
  dir = dir_vec,
  n_t = 100, n_s = 40,
  plot = FALSE
)
}
