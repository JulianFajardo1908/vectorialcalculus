% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/critical_points_nd.R
\name{critical_points_nd}
\alias{critical_points_nd}
\title{Critical points of an nD scalar field (no plot, n >= 3)}
\usage{
critical_points_nd(
  f,
  bounds,
  start_grid = NULL,
  n_random = 50L,
  max_grid_starts = 2000L,
  h = NULL,
  tol_grad = 1e-06,
  tol_merge = 0.001,
  tol_eig = 1e-06,
  maxit = 200,
  optim_method = c("BFGS", "Nelder-Mead"),
  seed = NULL,
  store_hessian = FALSE
)
}
\arguments{
\item{f}{Function \code{function(x)} that returns a numeric scalar; \code{x} is a numeric vector (length \eqn{n}).}

\item{bounds}{Domain bounds. Either:
\itemize{
\item an \eqn{n \times 2} numeric matrix (or data frame) with columns \code{lower, upper}, or
\item a list of length \eqn{n}, each element \code{c(lower, upper)}.
}}

\item{start_grid}{Integer vector of length \eqn{n} with the number of grid points per dimension
for deterministic starts (default \code{rep(5, n)} internally). The total grid size is capped by \code{max_grid_starts}.}

\item{n_random}{Number of additional random starts sampled uniformly in the hyper-rectangle.}

\item{max_grid_starts}{Maximum number of grid starts to actually instantiate (to avoid explosion).
If the full grid exceeds this, a random subset of that size is used. Default \code{2000}.}

\item{h}{Step(s) for finite differences. \code{NULL} (auto per component: \code{1e-4 * (1+abs(x_i))}),
a scalar, or a numeric vector of length \eqn{n}.}

\item{tol_grad}{Threshold on \eqn{\|\nabla f(x)\|} to accept a critical point (default \code{1e-6}).}

\item{tol_merge}{Euclidean distance to merge nearby candidates (default \code{1e-3}).}

\item{tol_eig}{Eigenvalue tolerance for classification (positive/negative vs. near-zero).}

\item{maxit}{Max iterations per \code{optim()} call.}

\item{optim_method}{Primary method for \code{optim()} (\code{"BFGS"} or \code{"Nelder-Mead"}).
If it errors, a fallback to \code{"Nelder-Mead"} is used.}

\item{seed}{Optional integer seed for reproducibility of random starts.}

\item{store_hessian}{Logical; if \code{TRUE}, returns the Hessian matrices for each critical point.}
}
\value{
A list with:
\itemize{
\item \code{critical_points}: a data.frame with columns \code{x1..xn}, \code{f}, \code{grad_norm}, \code{class}.
\item \code{eigvals}: a list column of numeric eigenvalue vectors (one per critical point).
\item \code{hessians}: (optional) a list column of Hessian matrices if \code{store_hessian=TRUE}.
\item \code{starts_info}: list with the actual number of grid and random starts used.
}
}
\description{
Finds critical points of a scalar field \eqn{f:\mathbb{R}^n \to \mathbb{R}} by
numerically solving \eqn{\nabla f(x)=0} via multi-start minimization of
\eqn{g(x)=\|\nabla f(x)\|^2}. Candidates closer than \code{tol_merge} are merged.
Each accepted point is classified using the Hessian eigenvalues.
}
\details{
Central finite differences (order 2) are used for gradients and the Hessian.
}
\examples{
\dontshow{if (interactive()) \{}
# Example 1: unique minimum at (1,1,1)
f1 <- function(x) sum((x - 1)^2)
B  <- rbind(c(-2, 3), c(-2, 3), c(-2, 3))   # 3D bounds
res1 <- critical_points_nd(f1, bounds = B, start_grid = c(5,5,5), n_random = 50, seed = 1)
res1$critical_points

# Example 2: saddle at the origin in 3D
f2 <- function(x) x[1]^2 + x[2]^2 - x[3]^2
B2 <- rbind(c(-1,1), c(-1,1), c(-1,1))
res2 <- critical_points_nd(f2, bounds = B2, start_grid = c(5,5,5), n_random = 30, seed = 123)
res2$critical_points

# Example 3 (4D): multiple critical points
f3 <- function(x) sum(x^4 - 2*x^2)  # per-dim extrema at {-1, 0, 1}
B3 <- do.call(rbind, replicate(4, c(-2,2), simplify = FALSE))
res3 <- critical_points_nd(f3, bounds = B3, start_grid = rep(4,4), n_random = 200, seed = 42)
head(res3$critical_points)
\dontshow{\}}

}
