% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lagrange_check.R
\name{lagrange_check}
\alias{lagrange_check}
\title{Optimality check with Lagrange multipliers and bordered Hessian}
\usage{
lagrange_check(f, g, x, h = NULL, tol = 1e-06)
}
\arguments{
\item{f}{Objective, \code{function(x)} returning a scalar. \code{x} is numeric (length n).}

\item{g}{Equality constraints. Either:
\itemize{
\item \code{function(x)} returning a numeric vector of length m, or
\item a \code{list} of scalar functions \code{function(x)} (one per constraint).
}}

\item{x}{Candidate point to evaluate (numeric vector of length n).}

\item{h}{Finite-difference step(s). Scalar, length-n vector, or \code{NULL}
(default \code{1e-4*(1+abs(x))} componentwise).}

\item{tol}{Tolerance for considering \eqn{g(x)\approx 0}, \eqn{rank(J)}, and minors \eqn{\Delta_k}.}
}
\value{
A list with:
\itemize{
\item \code{ok_stationarity}: norm of KKT residual \eqn{\|\nabla f - J^\top\lambda\|}.
\item \code{ok_feasible}: \eqn{\max_i |g_i(x)|}.
\item \code{lambda}: Lagrange multipliers \eqn{\lambda} (length m).
\item \code{J}: Jacobian (m×n).
\item \code{H_f}: Hessian of \eqn{f} (n×n).
\item \code{H_g}: list of Hessians \eqn{H_{g_i}} (each n×n).
\item \code{H_L}: Hessian of the Lagrangian (n×n).
\item \code{B}: bordered Hessian ( (m+n)×(m+n) ).
\item \code{minors}: \code{data.frame} with \eqn{\Delta_k}, its \code{sign} and \code{logAbsDet}.
\item \code{clasificacion}: \code{"minimo"}, \code{"maximo"} or \code{"indeterminado"}.
\item \code{notas}: notes about \eqn{rank(J)}, near-singularity, etc.
}
}
\description{
Evaluates, at a candidate point \eqn{x^\*}, the Lagrange conditions for a problem
with \strong{m} equality constraints \eqn{g_i(x)=0}, builds the \strong{bordered Hessian},
and classifies the candidate as \emph{minimum}, \emph{maximum}, or \emph{indeterminate/saddle}
using the signs of the \emph{leading principal minors}.
}
\details{
Let \eqn{f:\mathbb{R}^n\to\mathbb{R}} and \eqn{g:\mathbb{R}^n\to\mathbb{R}^m}.
At \eqn{x^\*}, with Jacobian \eqn{J = \nabla g(x^\*)} (m×n) and
\eqn{H_f = \nabla^2 f(x^\*)}, \eqn{H_{g_i} = \nabla^2 g_i(x^\*)}, the Hessian of
the Lagrangian is \eqn{H_L = H_f - \sum_{i=1}^m \lambda_i H_{g_i}}, where
\eqn{\lambda} satisfies \eqn{\nabla f(x^\*) = J^\top \lambda}. The \strong{bordered Hessian} is
\deqn{B = \begin{bmatrix} 0_{m\times m} & J \\ J^\top & H_L \end{bmatrix}.}

Criterion (leading principal minors \eqn{\Delta_k = \det B_{(m+k)}}, \eqn{k=1,\dots,n},
where \eqn{B_{(r)}} is the \eqn{r\times r} top-left submatrix):
\itemize{
\item \strong{Minimum}: \eqn{(-1)^m \Delta_k > 0} for all \eqn{k=1,\dots,n}.
\item \strong{Maximum}: the signs of \eqn{(-1)^m \Delta_k} \strong{alternate} with k:
negative, positive, negative, \dots
}

Everything is computed with \strong{second-order central finite differences}.
}
\examples{
## 1) Minimum with 1 constraint:  f(x,y)=x^2+y^2,  g(x,y)=x+y-1=0  -> (0.5,0.5)
f1 <- function(x) x[1]^2 + x[2]^2
g1 <- function(x) x[1] + x[2] - 1
lagrange_check(f1, g1, x = c(0.5, 0.5))

## 2) Maximum with 1 constraint:  f(x,y)=-(x^2+y^2),  g(x,y)=x+y-1=0  -> (0.5,0.5)
f2 <- function(x) -(x[1]^2 + x[2]^2)
lagrange_check(f2, g1, x = c(0.5, 0.5))

## 3) Two constraints in R^3 (min-norm with two planes)
f3 <- function(x) sum(x^2)
g3 <- list(function(x) x[1] + x[2] + x[3] - 1,
           function(x) x[1] - x[3])
# Candidate solution: x1=x3, 2*x1 + x2 = 1 -> x=(1/3,1/3,1/3)
lagrange_check(f3, g3, x = c(1,1,1)/3)

}
