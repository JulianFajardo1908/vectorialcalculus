% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/normal3d.R, R/tangent3d.R
\name{.assert_fun}
\alias{.assert_fun}
\title{Principal normal vectors N along a 3D curve (numeric)}
\usage{
.assert_fun(f, nm)

.assert_fun(f, nm)
}
\arguments{
\item{N_line}{Plotly style for the \eqn{N} segments.}

\item{X}{Function of one variable \code{t} returning \code{x(t)}.}

\item{Y}{Function of one variable \code{t} returning \code{y(t)}.}

\item{Z}{Function of one variable \code{t} returning \code{z(t)}.}

\item{a}{Lower endpoint of the interval \code{[a,b]}.}

\item{b}{Upper endpoint of the interval \code{[a,b]}.}

\item{t_points}{Numeric vector with the \code{t} values where \eqn{T} is evaluated/plotted.}

\item{h}{Step size for the centered finite-difference derivative (default \code{1e-4}).}

\item{plot}{Logical; if \code{TRUE}, plots curve + tangent segments with \pkg{plotly}.}

\item{n_samples}{Number of sample points for the curve (only if \code{plot = TRUE}).}

\item{vec_scale}{Base scale of the \eqn{T} segments. If \code{NULL}, it is estimated
(5\% of the span of the sampled curve).}

\item{vec_factor}{Multiplicative factor applied to \code{vec_scale} (default \code{1}).}

\item{curve_line}{Plotly line style for the curve, e.g. \code{list(color="blue", width=2)}.}

\item{T_line}{Plotly line style for the \eqn{T} segments, e.g. \code{list(color="red", width=5)}.}

\item{show_curve}{Logical; show the base curve.}

\item{show_points}{Logical; mark \eqn{r(t)} at \code{t_points}.}

\item{point_marker}{Plotly marker style for base points, e.g. \code{list(size=3)}.}

\item{scene}{Plotly 3D scene settings; default uses \code{aspectmode="data"}.}

\item{bg}{Background colors as \code{list(paper="white", plot="white")}.}

\item{tol}{Tolerance to detect \eqn{\|r'(t)\|\approx 0}.}
}
\value{
A \code{tibble} with columns \code{t, x, y, z, Nx, Ny, Nz}.

A \code{tibble} with columns \code{t, x, y, z, Tx, Ty, Tz}.
}
\description{
Computes the \strong{principal normal} \eqn{N(t)} at parameter values
\code{t_points}. With \eqn{r'(t)} and \eqn{r''(t)}, we form
\eqn{T = r'/\|r'\|}, then \eqn{B = \mathrm{normalize}(r' \times r'')}, and finally
\eqn{N = \mathrm{normalize}(B \times T)}. If \(\kappa \approx 0\),
\eqn{N} is undefined (returns \code{NA}).

Computes the \strong{unit tangent} \eqn{T(t) = r'(t)/\|r'(t)\|} at a set of
parameter values \code{t_points}. Optionally plots the curve \eqn{r(t)} on
\code{[a,b]} and overlays short segments representing \eqn{T} anchored at
\eqn{r(t)} using \pkg{plotly}.
}
\details{
Derivatives are computed via \emph{centered finite differences} and the curve
is sampled uniformly for plotting.
}
\examples{
X <- function(t) t*cos(t); Y <- function(t) t*sin(3*t); Z <- function(t) t
Ntab <- normal3d(X, Y, Z, a = 0, b = 2*pi, t_points = c(pi/3, pi, 5*pi/3))
# \donttest{ if (requireNamespace("plotly", quietly = TRUE)) {
#   normal3d(X, Y, Z, 0, 2*pi, t_points = c(pi/3, pi, 5*pi/3),
#            plot = TRUE, n_samples = 300,
#            vec_factor = 1.4,
#            N_line = list(color="green", width=5))
# } }
X <- function(t) t*cos(t); Y <- function(t) t*sin(3*t); Z <- function(t) t
tang <- tangent3d(X, Y, Z, a = 0, b = 2*pi, t_points = c(pi/3, pi, 5*pi/3))
# \donttest{ if (requireNamespace("plotly", quietly = TRUE)) {
#   tangent3d(X, Y, Z, 0, 2*pi, t_points = c(pi/3, pi, 5*pi/3),
#             plot = TRUE, n_samples = 300,
#             vec_factor = 1.4,
#             T_line = list(color="red", width=5))
# } }
}
