% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cylindrical_surface3d.R
\name{cylindrical_surface3d}
\alias{cylindrical_surface3d}
\title{Cylindrical surface generated by a curve r(t) in a fixed direction u}
\usage{
cylindrical_surface3d(
  X,
  Y,
  Z,
  a,
  b,
  s_range,
  dir,
  n_t = 200,
  n_s = 60,
  plot = FALSE,
  surface_colorscale = "Blues",
  surface_opacity = 0.35,
  show_surface_grid = TRUE,
  surface_grid_color = "rgba(60,80,200,0.25)",
  surface_grid_width = 1,
  show_curve = TRUE,
  curve_line = list(color = "red", width = 2, dash = "solid"),
  show_edge_a = TRUE,
  show_edge_b = FALSE,
  edge_line = list(color = "blue", width = 2, dash = "solid"),
  show_rulings = TRUE,
  rulings_count = 12,
  rulings_at = NULL,
  rulings_line = list(color = "black", width = 1, dash = "solid"),
  show_axis_grid = FALSE,
  scene = list(aspectmode = "data", xaxis = list(title = "x"), yaxis = list(title = "y"),
    zaxis = list(title = "z")),
  bg = list(paper = "white", plot = "white"),
  lighting = list(ambient = 1, diffuse = 0.15, specular = 0, roughness = 1, fresnel = 0)
)
}
\arguments{
\item{X, Y, Z}{Functions \code{x(t)}, \code{y(t)}, \code{z(t)}.}

\item{a, b}{Endpoints of the parameter interval in \code{t}.}

\item{s_range}{Numeric vector \code{c(c, d)} with the range in \code{s}.}

\item{dir}{Direction vector \code{u = c(ux, uy, uz)} (non-zero).}

\item{n_t, n_s}{Mesh resolutions in \code{t} and \code{s}.}

\item{plot}{Logical; if \code{TRUE}, draw with \pkg{plotly}.}

\item{surface_colorscale}{Plotly colorscale for the surface (e.g. \code{"Blues"}).}

\item{surface_opacity}{Surface opacity (0â€“1).}

\item{show_surface_grid}{Logical; draw a mesh grid over the surface.}

\item{surface_grid_color, surface_grid_width}{Color and width of the surface grid.}

\item{show_curve}{Logical; draw the generating curve \eqn{r(t)}.}

\item{curve_line}{Style for \eqn{r(t)} (e.g. \code{list(color="red", width=2)}).}

\item{show_edge_a}{Logical; draw \eqn{G(a,s)}.}

\item{show_edge_b}{Logical; draw \eqn{G(b,s)}.}

\item{edge_line}{Line style for the boundary curves \eqn{G(a,s)}, \eqn{G(b,s)}.}

\item{show_rulings}{Logical; draw straight rulings.}

\item{rulings_count}{Number of rulings (used if \code{rulings_at} is \code{NULL}).}

\item{rulings_at}{Numeric vector with exact \code{t} positions for rulings.}

\item{rulings_line}{Line style for rulings (e.g. \code{list(color="black", width=1)}).}

\item{show_axis_grid}{Logical; show axis grids.}

\item{scene}{3D scene settings (default \code{aspectmode="data"}).}

\item{bg}{Background colors: \code{list(paper="white", plot="white")}.}

\item{lighting}{Lighting to soften highlights in \code{add_surface}.}
}
\value{
A list with:
\itemize{
\item \code{t_seq}, \code{s_seq}
\item \code{Xmat}, \code{Ymat}, \code{Zmat} (matrices \code{n_s x n_t})
\item \code{curve} (data.frame with the sampled generator curve)
\item \code{edge_a}, \code{edge_b} (data.frames with boundary curves if requested)
\item \code{u_hat} (normalized direction)
}
}
\description{
Given \eqn{r(t) = (X(t), Y(t), Z(t)}, \eqn{t \in [a,b]}, and a fixed vector
\eqn{u \in \mathbb{R}^3}, the cylindrical surface is
\deqn{G(t,s) = r(t) + s\,\hat u,\qquad s \in [c,d],}
where \eqn{\hat u = u / \|u\|}.
}
\details{
In addition to the generating curve \eqn{r(t)} and the boundary curves
\eqn{G(a,s)}, \eqn{G(b,s)}, you can draw \strong{rulings} (straight generators):
the lines \eqn{s \mapsto G(t_i, s)} for selected \eqn{t_i}.
}
\examples{
# r(t) = (t^2, cos t, sin t), t in [0, pi], u = (1,2,0), s in [-1, 1]
X <- function(t) t^2; Y <- function(t) cos(t); Z <- function(t) sin(t)
cylindrical_surface3d(
  X, Y, Z, a = 0, b = pi,
  s_range = c(-1, 1), dir = c(1, 2, 0),
  plot = TRUE, surface_colorscale = "Blues",
  surface_opacity = 0.35, show_surface_grid = TRUE,
  show_rulings = TRUE, rulings_count = 10
)

}
