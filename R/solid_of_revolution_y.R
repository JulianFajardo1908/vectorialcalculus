#' Solid of revolution of y = f(x) about y = a (plot + volume + surface area)
#'
#' Builds a 3D Plotly surface for the solid generated by rotating the curve
#' \eqn{(x, f(x))} around the horizontal line \eqn{y = a} on \eqn{[x_{\min}, x_{\max}]},
#' and computes:
#' \itemize{
#'   \item \strong{Volume}: \eqn{V = \pi \int_{x_{\min}}^{x_{\max}} (f(x)-a)^2\,dx}.
#'   \item \strong{Lateral surface area}: \eqn{S = 2\pi \int_{x_{\min}}^{x_{\max}}
#'         |f(x)-a|\,\sqrt{1+(f'(x))^2}\,dx}.
#' }
#'
#' The plot renders \emph{only} the 3D surface; it does not shade/fill the 2D area under the curve.
#' Numerical derivatives use central finite differences (order 2) with one-sided fallback near ends.
#' Integrals use \code{stats::integrate}.
#'
#' @param f \code{function(x)} integrable on \code{xlim}; may or may not be vectorized.
#' @param xlim Numeric length-2 \code{c(xmin, xmax)} with \code{xmax > xmin}.
#' @param a Numeric constant: horizontal axis of revolution (\eqn{y=a}).
#' @param nx,nt Integers (>= 2): mesh resolution along \eqn{x} and angle \eqn{\theta\in[0,2\pi]}.
#' @param deriv Optional \code{function(x)} giving \eqn{f'(x)}; if \code{NULL}, a numeric derivative is used.
#' @param h Step for numeric derivative. If \code{NULL}, uses \code{1e-5*(1+abs(x))} per point.
#' @param include_end_caps Logical; if \code{TRUE}, adds end-cap areas \eqn{\pi(f(x)-a)^2} at the interval ends to
#'   \code{surface_area_total}. Lateral area is always returned in \code{surface_area_lateral}.
#' @param colors List of colors: \code{list(surface="steelblue", axis="black", curve="firebrick")}.
#' @param opacity Surface opacity in \eqn{[0,1]}.
#' @param show_axis Logical; if \code{TRUE}, draws the revolution axis \eqn{y=a} as a line at \code{z=0}.
#' @param show_profile_curve Logical; if \code{TRUE}, overlays the generating curve \eqn{(x,f(x))} mapped onto
#'   the surface at one or more angles \code{curve_thetas}.
#' @param curve_thetas Numeric vector of angles (radians) where the profile curve is drawn on the surface.
#'   For example, \code{0} draws it in the plane \code{z=0}; \code{pi/2} draws it at \code{y=a}.
#' @param curve_width,curve_opacity Line style for the profile curve(s).
#' @param scene Plotly scene (axes titles, aspect, etc.).
#'
#' @return A list with:
#' \itemize{
#'   \item \code{volume}: numeric, \eqn{V}.
#'   \item \code{surface_area_lateral}: numeric, lateral area \eqn{S}.
#'   \item \code{surface_area_total}: numeric, \eqn{S} (+ caps if \code{include_end_caps=TRUE}).
#'   \item \code{figure}: \pkg{plotly} object (or \code{NULL} if \pkg{plotly} is missing).
#' }
#'
#' @examples
#' \dontshow{if (interactive()) \{}
#' f <- function(x) 0.4 + 0.5*exp(-x^2/2)*cos(3*x)  # a smooth bump above ~0
#' out <- solid_of_revolution_y(
#'   f, xlim = c(-2, 2), a = 0,
#'   nx = 120, nt = 160,
#'   include_end_caps = FALSE,
#'   colors = list(surface="#6baed6", axis="black", curve="#e63946"),
#'   show_profile_curve = TRUE, curve_thetas = c(0, pi/2),
#'   curve_width = 5
#' )
#' out$volume; out$surface_area_lateral
#' \dontshow{\}}
#'
#' @export
solid_of_revolution_y <- function(
    f,
    xlim,
    a,
    nx = 120L,
    nt = 120L,
    deriv = NULL,
    h = NULL,
    include_end_caps = FALSE,
    colors = list(surface = "steelblue", axis = "black", curve = "firebrick"),
    opacity = 0.9,
    show_axis = TRUE,
    show_profile_curve = TRUE,
    curve_thetas = 0,
    curve_width = 4,
    curve_opacity = 1,
    scene = list(
      aspectmode = "data",
      xaxis = list(title = "x"),
      yaxis = list(title = "y"),
      zaxis = list(title = "z")
    )
){
  stopifnot(is.function(f))
  if (length(xlim)!=2 || !is.finite(xlim[1]) || !is.finite(xlim[2]) || xlim[2] <= xlim[1])
    stop("'xlim' must be c(xmin, xmax) with finite numbers and xmax > xmin.", call. = FALSE)
  if (!is.numeric(a) || length(a)!=1 || !is.finite(a))
    stop("'a' must be a finite numeric scalar.", call. = FALSE)
  if (nx < 2 || nt < 2) stop("'nx' and 'nt' must be >= 2.", call. = FALSE)

  # Vectorized wrappers (in case f/deriv are not vectorized)
  f_vec <- function(x) vapply(x, f, numeric(1))
  if (is.null(deriv)) {
    d1 <- function(x) {
      hx0 <- if (is.null(h)) 1e-5 else as.numeric(h)
      g <- function(x0) {
        hx <- if (is.null(h)) 1e-5 * (1 + abs(x0)) else hx0
        (f(x0 + hx) - f(x0 - hx)) / (2 * hx)
      }
      vapply(x, g, numeric(1))
    }
    deriv_vec <- d1
  } else {
    stopifnot(is.function(deriv))
    deriv_vec <- function(x) vapply(x, deriv, numeric(1))
  }

  # --- Integrands
  vol_integrand <- function(x) { r <- f_vec(x) - a; (r*r) * pi }
  area_integrand <- function(x) {
    r <- abs(f_vec(x) - a); fp <- deriv_vec(x)
    2*pi * r * sqrt(1 + fp*fp)
  }

  V <- try(stats::integrate(vol_integrand, lower = xlim[1], upper = xlim[2])$value, silent = TRUE)
  if (inherits(V, "try-error")) stop("Volume integral failed; check that f(x) is integrable on 'xlim'.", call. = FALSE)

  S_lat <- try(stats::integrate(area_integrand, lower = xlim[1], upper = xlim[2])$value, silent = TRUE)
  if (inherits(S_lat, "try-error")) stop("Surface-area integral failed; check f and its derivative on 'xlim'.", call. = FALSE)

  S_tot <- S_lat
  if (isTRUE(include_end_caps)) {
    r0 <- f_vec(xlim[1]) - a
    r1 <- f_vec(xlim[2]) - a
    S_tot <- S_lat + pi * (r0*r0 + r1*r1)
  }

  # --- Plot
  have_plotly <- requireNamespace("plotly", quietly = TRUE)
  fig <- NULL
  if (have_plotly) {
    xs <- seq(xlim[1], xlim[2], length.out = nx)
    thetas <- seq(0, 2*pi, length.out = nt)
    r <- f_vec(xs) - a

    # Parametric surface matrices (nt x nx)
    X <- matrix(rep(xs, each = nt), nrow = nt, ncol = nx)
    Y <- matrix(a, nrow = nt, ncol = nx) + outer(cos(thetas), r, `*`)
    Z <- outer(sin(thetas), r, `*`)

    p <- plotly::plot_ly()
    p <- plotly::add_surface(
      p,
      x = X, y = Y, z = Z,
      showscale = FALSE,
      opacity = opacity,
      colorscale = list(list(0, colors$surface %||% "steelblue"),
                        list(1, colors$surface %||% "steelblue")),
      name = "solid"
    )

    if (isTRUE(show_axis)) {
      p <- plotly::add_trace(
        p,
        x = xlim, y = c(a, a), z = c(0, 0),
        type = "scatter3d", mode = "lines",
        line = list(color = colors$axis %||% "black", width = 4),
        name = "axis y=a", showlegend = TRUE, inherit = FALSE
      )
    }

    # Profile curve(s) mapped onto the surface: for each theta,
    # (x, f(x)) -> (x, a + (f(x)-a)*cos(theta), (f(x)-a)*sin(theta))
    if (isTRUE(show_profile_curve) && length(curve_thetas) > 0) {
      # dense x for a smooth polyline
      xsc <- seq(xlim[1], xlim[2], length.out = max(400L, nx))
      rc  <- f_vec(xsc) - a
      for (th in as.numeric(curve_thetas)) {
        yc <- a + rc * cos(th)
        zc <-       rc * sin(th)
        p <- plotly::add_trace(
          p, x = xsc, y = yc, z = zc,
          type = "scatter3d", mode = "lines",
          line = list(color = colors$curve %||% "firebrick", width = curve_width),
          opacity = curve_opacity,
          name = sprintf("profile f(x) @ \u03B8 = %.2f rad", th),
          showlegend = TRUE, inherit = FALSE
        )
      }
    }

    p <- plotly::layout(
      p,
      title = "Solid of revolution about y = a (with profile curve)",
      scene = scene
    )
    fig <- p
    print(fig)
  } else {
    warning("Package 'plotly' not found; returning numeric results only.", call. = FALSE)
  }

  list(
    volume = V,
    surface_area_lateral = S_lat,
    surface_area_total = S_tot,
    figure = fig
  )
}

`%||%` <- function(a, b) if (!is.null(a)) a else b
