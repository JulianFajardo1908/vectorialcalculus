#' Cylindrical surface generated by a curve r(t) in a fixed direction u
#'
#' Given \eqn{r(t) = (X(t), Y(t), Z(t)}, \eqn{t \in [a,b]}, and a fixed vector
#' \eqn{u \in \mathbb{R}^3}, the cylindrical surface is
#' \deqn{G(t,s) = r(t) + s\,\hat u,\qquad s \in [c,d],}
#' where \eqn{\hat u = u / \|u\|}.
#'
#' In addition to the generating curve \eqn{r(t)} and the boundary curves
#' \eqn{G(a,s)}, \eqn{G(b,s)}, you can draw \strong{rulings} (straight generators):
#' the lines \eqn{s \mapsto G(t_i, s)} for selected \eqn{t_i}.
#'
#' @param X,Y,Z Functions \code{x(t)}, \code{y(t)}, \code{z(t)}.
#' @param a,b Endpoints of the parameter interval in \code{t}.
#' @param s_range Numeric vector \code{c(c, d)} with the range in \code{s}.
#' @param dir Direction vector \code{u = c(ux, uy, uz)} (non-zero).
#' @param n_t,n_s Mesh resolutions in \code{t} and \code{s}.
#' @param plot Logical; if \code{TRUE}, draw with \pkg{plotly}.
#' @param surface_colorscale Plotly colorscale for the surface (e.g. \code{"Blues"}).
#' @param surface_opacity Surface opacity (0–1).
#' @param show_surface_grid Logical; draw a mesh grid over the surface.
#' @param surface_grid_color,surface_grid_width Color and width of the surface grid.
#' @param show_curve Logical; draw the generating curve \eqn{r(t)}.
#' @param curve_line Style for \eqn{r(t)} (e.g. \code{list(color="red", width=2)}).
#' @param show_edge_a Logical; draw \eqn{G(a,s)}.
#' @param show_edge_b Logical; draw \eqn{G(b,s)}.
#' @param edge_line Line style for the boundary curves \eqn{G(a,s)}, \eqn{G(b,s)}.
#' @param show_rulings Logical; draw straight rulings.
#' @param rulings_count Number of rulings (used if \code{rulings_at} is \code{NULL}).
#' @param rulings_at Numeric vector with exact \code{t} positions for rulings.
#' @param rulings_line Line style for rulings (e.g. \code{list(color="black", width=1)}).
#' @param show_axis_grid Logical; show axis grids.
#' @param scene 3D scene settings (default \code{aspectmode="data"}).
#' @param bg Background colors: \code{list(paper="white", plot="white")}.
#' @param lighting Lighting to soften highlights in \code{add_surface}.
#'
#' @return A list with:
#' \itemize{
#'   \item \code{t_seq}, \code{s_seq}
#'   \item \code{Xmat}, \code{Ymat}, \code{Zmat} (matrices \code{n_s x n_t})
#'   \item \code{curve} (data.frame with the sampled generator curve)
#'   \item \code{edge_a}, \code{edge_b} (data.frames with boundary curves if requested)
#'   \item \code{u_hat} (normalized direction)
#' }
#'
#' @examples
#' # r(t) = (t^2, cos t, sin t), t in [0, pi], u = (1,2,0), s in [-1, 1]
#' X <- function(t) t^2; Y <- function(t) cos(t); Z <- function(t) sin(t)
#' cylindrical_surface3d(
#'   X, Y, Z, a = 0, b = pi,
#'   s_range = c(-1, 1), dir = c(1, 2, 0),
#'   plot = TRUE, surface_colorscale = "Blues",
#'   surface_opacity = 0.35, show_surface_grid = TRUE,
#'   show_rulings = TRUE, rulings_count = 10
#' )
#'
#' @export
cylindrical_surface3d <- function(
    X, Y, Z,
    a, b,
    s_range,
    dir,
    n_t = 200,
    n_s = 60,
    plot = FALSE,
    surface_colorscale = "Blues",
    surface_opacity    = 0.35,
    show_surface_grid  = TRUE,
    surface_grid_color = "rgba(60,80,200,0.25)",
    surface_grid_width = 1,
    show_curve = TRUE,
    curve_line = list(color = "red", width = 2, dash = "solid"),
    show_edge_a = TRUE,
    show_edge_b = FALSE,
    edge_line = list(color = "blue", width = 2, dash = "solid"),
    show_rulings = TRUE,
    rulings_count = 12,
    rulings_at = NULL,
    rulings_line = list(color = "black", width = 1, dash = "solid"),
    show_axis_grid = FALSE,
    scene = list(
      aspectmode = "data",
      xaxis = list(title = "x"),
      yaxis = list(title = "y"),
      zaxis = list(title = "z")
#' @noRd
#' @noRd
    ),
    bg = list(paper = "white", plot = "white"),
    lighting = list(ambient = 1, diffuse = 0.15, specular = 0, roughness = 1, fresnel = 0)
) {
#' @noRd
  # --- Validations ----------------------------------------------------
  if (!is.numeric(s_range) || length(s_range) != 2L || any(!is.finite(s_range)))
    stop("'s_range' must be a finite numeric vector c(c, d).", call. = FALSE)
  if (!is.numeric(dir) || length(dir) != 3L || any(!is.finite(dir)))
    stop("'dir' must be a finite numeric vector c(ux, uy, uz).", call. = FALSE)
  if (b < a) stop("'b' must be >= 'a'.", call. = FALSE)

  # --- Normalized direction ------------------------------------------
  u <- as.numeric(dir)
  nu <- sqrt(sum(u*u))
  if (!is.finite(nu) || nu == 0) stop("'dir' cannot be the zero vector.", call. = FALSE)
  u <- u / nu  # û

  # --- Mesh -----------------------------------------------------------
  t_seq <- seq(a, b, length.out = n_t)
  s_seq <- seq(s_range[1], s_range[2], length.out = n_s)

  # r(t) sampled
  Rt <- cbind(X(t_seq), Y(t_seq), Z(t_seq))  # n_t x 3

  # Surface G(t,s) = r(t) + s u  -> matrices n_s x n_t
  Xmat <- matrix(NA_real_, n_s, n_t)
  Ymat <- matrix(NA_real_, n_s, n_t)
  Zmat <- matrix(NA_real_, n_s, n_t)

  for (j in seq_len(n_t)) {
    Xmat[, j] <- Rt[j, 1] + s_seq * u[1]
    Ymat[, j] <- Rt[j, 2] + s_seq * u[2]
    Zmat[, j] <- Rt[j, 3] + s_seq * u[3]
  }

  # Generating curve
  curve_df <- tibble::tibble(t = t_seq, x = Rt[,1], y = Rt[,2], z = Rt[,3])

  # Boundary curves G(a,s) and G(b,s)
  edge_a <- edge_b <- NULL
  if (isTRUE(show_edge_a)) {
    ra <- Rt[1, ]
    edge_a <- tibble::tibble(
      s = s_seq,
      x = ra[1] + s_seq * u[1],
      y = ra[2] + s_seq * u[2],
      z = ra[3] + s_seq * u[3]
    )
  }
  if (isTRUE(show_edge_b)) {
    rb <- Rt[n_t, ]
    edge_b <- tibble::tibble(
      s = s_seq,
      x = rb[1] + s_seq * u[1],
      y = rb[2] + s_seq * u[2],
      z = rb[3] + s_seq * u[3]
    )
  }

  # --- Plot -----------------------------------------------------------
  if (isTRUE(plot)) {
    if (!requireNamespace("plotly", quietly = TRUE)) {
      warning("To plot you need 'plotly' installed.", call. = FALSE)
    } else {
      contours_arg <- if (isTRUE(show_surface_grid)) list(
        x = list(show = TRUE, color = surface_grid_color, width = surface_grid_width),
        y = list(show = TRUE, color = surface_grid_color, width = surface_grid_width),
        z = list(show = FALSE)
      ) else NULL

      plt <- plotly::plot_ly() |>
        plotly::add_surface(
          x = Xmat, y = Ymat, z = Zmat,
          colorscale = surface_colorscale,
          showscale  = FALSE,
          opacity    = surface_opacity,
          lighting   = lighting,
          contours   = contours_arg
        )

      if (isTRUE(show_curve)) {
        plt <- plt |>
          plotly::add_trace(
            data = curve_df, x = ~x, y = ~y, z = ~z,
            type = "scatter3d", mode = "lines",
            line = curve_line, hoverinfo = "none", showlegend = FALSE
          )
      }

      if (!is.null(edge_a)) {
        plt <- plt |>
          plotly::add_trace(
            data = edge_a, x = ~x, y = ~y, z = ~z,
            type = "scatter3d", mode = "lines",
            line = edge_line, hoverinfo = "none", showlegend = FALSE
          )
      }
      if (!is.null(edge_b)) {
        plt <- plt |>
          plotly::add_trace(
            data = edge_b, x = ~x, y = ~y, z = ~z,
            type = "scatter3d", mode = "lines",
            line = edge_line, hoverinfo = "none", showlegend = FALSE
          )
      }

      # Rulings
      if (isTRUE(show_rulings)) {
        t_pos <- if (is.null(rulings_at)) {
          seq(a, b, length.out = rulings_count)
        } else {
          as.numeric(rulings_at)
        }
        t_pos <- t_pos[is.finite(t_pos) & t_pos >= a & t_pos <= b]
        if (length(t_pos)) {
          for (ti in t_pos) {
            ri <- c(X(ti), Y(ti), Z(ti))
            xr <- ri[1] + s_seq * u[1]
            yr <- ri[2] + s_seq * u[2]
            zr <- ri[3] + s_seq * u[3]
            plt <- plt |>
              plotly::add_trace(
                x = xr, y = yr, z = zr,
                type = "scatter3d", mode = "lines",
                line = rulings_line, hoverinfo = "none", showlegend = FALSE
              )
          }
        }
      }

      # Axis grids if requested
      scene_final <- scene
      for (ax in c("xaxis","yaxis","zaxis")) {
        if (is.null(scene_final[[ax]])) scene_final[[ax]] <- list()
        scene_final[[ax]]$showgrid <- isTRUE(show_axis_grid)
      }

      plt <- plt |>
        plotly::layout(
          title = "Cylindrical surface G(t,s) = r(t) + s û",
          scene = scene_final,
          paper_bgcolor = bg$paper,
          plot_bgcolor  = bg$plot
        )
      print(plt)
    }
  }

  list(
    t_seq = t_seq, s_seq = s_seq,
    Xmat = Xmat, Ymat = Ymat, Zmat = Zmat,
    curve = curve_df,
    edge_a = edge_a, edge_b = edge_b,
    u_hat = u
  )
}
